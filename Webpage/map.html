<!DOCTYPE html>
<html>
<head onload="startMapUpdate()">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>Kerbal Maps</title>

    <link rel="stylesheet" type="text/css" href="css/leafletksp.css" />
    <link rel="stylesheet" href="css/jKSPWAPICore.css" />

    <script type="text/javascript" src="js/leafletksp.js"></script>

    <script type="text/javascript" src="js/jquery-1.9.1.min.js"></script>
    <script type="text/javascript" src="js/jKSPWAPICore.js"></script>
    <script>
    	var endlessLoopCount = 1;
    	var UpdateMarkerJSON = JSON.parse('{"Main":{"Debris":{"ID":[[10,10, "GILLY", "1000/10", 3000]]},"Public_Frequency":{"ID":[[-10,-10, "GILLY", "100/10", 3000, "NOT A REAL SHIP", "Boat"]]}}}')
        
    async function startMapUpdate() {
        console.log("Update test!")
        while (endlessLoopCount > 0) {
        	const result = await updateMap();
  			//console.log(result);
  			resetMap()
  			try {
  			UpdateMarkerJSON.Main.Debris.ID.forEach((element) => {
 				//console.log(element)
 				var Heights = element[3].toString().split("/")
 				var newmarker = [L.marker([element[0], element[1]], {icon: L.KSP.Icon.DEBRIS}).bindPopup("<strong>Debris</strong><br>" + Math.round(element[0]) + " : " + Math.round(element[1]) + "<br>Altitude: " + Math.round(Heights[0]) + "/" + Math.round(Heights[1]) + "m<br>Velocity: " + Math.round(element[4]) + "m/s")]; 
 				eval("newmarker[0].addTo(L.KSP.CelestialBody." + eval("element[2]") + ".overlays.Debris)")
			})
  			UpdateMarkerJSON.Main.Public_Frequency.ID.forEach((element) => {
 				//console.log(element)
 				var Heights = element[3].toString().split("/")
 				var newmarker = [L.marker([element[0], element[1]], {icon: L.KSP.Icon.PUBLIC}).bindPopup("<strong>" + element[5] + "</strong><br>" + Math.round(element[0]) + " : " + Math.round(element[1]) + "<br>Type: " + element[6] + "<br>Altitude: " + Math.round(Heights[0]) + "m / " + Math.round(Heights[1]) + "m<br>Velocity: " + Math.round(element[4]) + "m/s")]; 
 				eval("newmarker[0].addTo(L.KSP.CelestialBody." + eval("element[2]") + ".overlays.Public_Frequency)")
			})
			} catch(e) {
			console.warn("ERROR BELOW")
			console.error(e)
			console.warn("JSON BELOW")
			console.warn(UpdateMarkerJSON)
			}
  			endlessLoopCount = endlessLoopCount + 1;
  		}
    }
    function resetMap() {
    	L.KSP.CelestialBody.EELOO.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.EELOO.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.POL.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.POL.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.BOP.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.BOP.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.TYLO.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.TYLO.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.VALL.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.VALL.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.LAYTHE.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.LAYTHE.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.DRES.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.DRES.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.IKE.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.IKE.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.DUNA.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.DUNA.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.MINMUS.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.MINMUS.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.MUN.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.MUN.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.KERBIN.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.KERBIN.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.GILLY.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.GILLY.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.EVE.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.EVE.overlays.Public_Frequency.clearLayers()
		L.KSP.CelestialBody.MOHO.overlays.Debris.clearLayers()
		L.KSP.CelestialBody.MOHO.overlays.Public_Frequency.clearLayers()
    }
    function updateMap() {
    return new Promise(resolve => {
    setTimeout(() => {
      var txtFile = new XMLHttpRequest();
    txtFile.onreadystatechange = function () {
    var allText = "";
        if (txtFile.readyState === XMLHttpRequest.DONE && txtFile.status == 200) {
        
            allText = txtFile.responseText;
            UpdateMarkerJSON = JSON.parse(allText);
}
        

    }
    txtFile.open("GET", 'https://jsonblob.com/api/jsonBlob/[PLACE_ID_HERE]', true);
    txtFile.send(null);
      resolve(UpdateMarkerJSON);
    }, 2000);
  });
    }
    function sleep(ms)
	{
    	var date = new Date();
  	  var curDate = null;
 	   do { curDate = new Date(); }
  	  while(curDate-date < ms);
	}
        function startMap() {
            var previousBody = -1;
            var newBody;
            jQuery(document).ready(function ($) {
                map = new L.KSP.Map('map', {
                    layers: [L.KSP.CelestialBody.KERBIN],
                    zoom: 1,
                    center: [-0.1027, -74.5754],
                    bodyControl: true,
                    layerControl: false,
                    scaleControl: true
                });
                map.fitWorld();
                rawData = [[0]];
               /* var marker = [L.marker([0, 0]), L.marker([0, 0])];
                marker[0].addTo(map); */
                var i = 0;/*
                while (i < 10) {
                	sleep(100)
                	console.log("Test!")
    	            var newmarker = [L.marker([Math.floor(Math.random() * 100), Math.floor(Math.random() * 100)]), L.marker([Math.floor(Math.random() * 100), Math.floor(Math.random() * 100)])];
	                newmarker[0].addTo(map);
                	var i = i + 1;
				}*/
				/*L.KSP.CelestialBody.EELOO.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.EELOO.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.POL.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.POL.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.BOP.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.BOP.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.TYLO.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.TYLO.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.VALL.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.VALL.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.LAYTHE.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.LAYTHE.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.DRES.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.DRES.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.IKE.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.IKE.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.DUNA.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.DUNA.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.MINMUS.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.MINMUS.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.MUN.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.MUN.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.KERBIN.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.KERBIN.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.GILLY.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.GILLY.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.EVE.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.EVE.overlays.Public_Frequency.addTo(map)
				L.KSP.CelestialBody.MOHO.overlays.Debris.addTo(map)
				L.KSP.CelestialBody.MOHO.overlays.Public_Frequency.addTo(map)*/
				resetMap()
				startMapUpdate()
                /*jKSPWAPI.initPoll("longs=v.long&lat=v.lat&name=v.name&alt=v.altitude&m=v.surfaceVelocity&body=v.body", function (rawData) { }, function (rawData, d) {

                    if (previousBody != d.body) {
                        try {
                            newBody = L.KSP.CelestialBody[d.body.toUpperCase()];
                            newBody.addTo(map);
                            previousBody = d.body;
                        } catch (e) {
                            if (d.body === undefined) {
                                previousBody = d.body;
                            } else {
                                //alert("Body not supported yet. (" + d.body + ")")
                                previousBody = -1;
                            }
                            
                        }
                    }

                    if (!isNaN(d.lat) && !isNaN(d.longs)) {
                        marker[0].setLatLng([d.lat, (d.longs > 180 ? d.longs - 360.0 : d.longs)]);
                        marker[0].bindPopup(d.name + " </br>Altitude: " + d.alt + "</br>Surface Velocity: " + d.m);
                        marker[0].update();
                    }
                }, rawData)*/
            });
        }
    </script>
</head>
<body onload="startMap();" style="padding: 0; margin: 0;">
    <div id="map" class="map" style="padding: 0; margin: 0; height: 100%;"></div>
</body>
</html>
